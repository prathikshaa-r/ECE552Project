module alu(data_operandA, data_operandB, ctrl_ALUopcode, ctrl_shiftamt, data_result, isNotEqual, isLessThan, overflow);

   input [31:0] data_operandA, data_operandB;
   input [4:0] ctrl_ALUopcode, ctrl_shiftamt;

   output [31:0] data_result;
   output isNotEqual, isLessThan, overflow;
   
	wire [31:0] sra, sll, bitAnd, bitOr, sum, subs, f1, f2, data_operandBnot;
	wire c_out, c, c_of, andof, equal;
  
	//adder
	CLA_32bit  adder(data_operandA, data_operandB, 1'b0, sum, c_out); //00000
	
	//subtracting
	bitwiseNOT bNot(data_operandB, data_operandBnot);
	CLA_32bit subt(data_operandA, data_operandBnot, 1'b1, subs, c);	//00001
	
	//shift right arhitmetic
	barrel b_SRA(data_operandA, 1'b0, ctrl_shiftamt, sra);             //00101
	
	//shift left logical
	barrel b_SLL(data_operandA, 1'b1, ctrl_shiftamt, sll);             //00100
	
	//bitwise and
	bitwiseAND bitand(data_operandA, data_operandB, bitAnd);           //00010
	
	//bitwise or
	bitwiseOR bitor(data_operandA, data_operandB, bitOr);              //00011
	
	
	//not equal
	notEqual nE(subs, c, isNotEqual);

	//less than
	LessThan ls(data_operandA[31], data_operandB[31], subs[31],isNotEqual, isLessThan);
	//and andOF(andof, isNotEqual, c);
	
	assign overflow = ctrl_ALUopcode[0] ? c_out: c;
	
	//ALU mux logic
	wire [31:0] a, b; 

	mux_4 upper(sum, subs, bitAnd, bitOr, f1, ctrl_ALUopcode[0], ctrl_ALUopcode[1]);
	mux_4 lower(sll, sra, a, b, f2, ctrl_ALUopcode[0], ctrl_ALUopcode[1]);
	assign data_result = ctrl_ALUopcode[2] ? f2 : f1;
	

endmodule
